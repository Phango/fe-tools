"use strict";

const fs = require("fs");
const { resolve: pathResolve, dirname } = require("path");
const util = require("util");
const chalk = require("chalk");
const inquirer = require("inquirer");
const simpleGit = require("simple-git/promise")(__dirname);
const mkdirp = require("mkdirp");

const {
  TEMPLATES_DIR,
  COMPONENTS_DIR,
  PAGES_DIR,
  SCSS_MAIN,
  PAGES_MAIN,
  JS_COMPONENTS_MAIN,
  TS_COMPONENTS_MAIN,
  KARMA_MAIN
} = require("../config");


/**
 * Enum for assemble data file options.
 * @readonly
 * @enum {string}
 */
const DATA_FILE_TYPES = {JSON: ".json", YAML: ".yaml"};

const IMPORT_PLACEHOLDER = "IMPORT-PLACEHOLDER";


const jsTpl = getTemplate("jsTemplate");
const tsTpl = getTemplate("tsTemplate");
const scssTpl = getTemplate("scssTemplate");
const hbsTpl = getTemplate("hbsTemplate");
const hbsPageTpl = getTemplate("hbsPageTemplate");
const galenTestTpl = getTemplate("galenTestTemplate");
const galenSpecTpl = getTemplate("galenSpecTemplate");
const unitTpl = getTemplate("karmaTestsTemplate");
const mdTpl = getTemplate("mdTemplate");
const jsonTpl = getTemplate("jsonTemplate");
const yamlTpl = getTemplate("yamlTemplate");
const hbdDemoTpl = getTemplate("hbsDemoTemplate");

// for getting confirmation regarding overriding of existing files, ask user in cli
// shouldn't be used for example when files are generated by a project scaffolding scripts,
// or tests
let useInquirer = false;

let gitAdd = false;

/**
 * add import statement to the given file
 *
 * @param {string} path - path of the file which should get the import statement added to
 * @param {string} importStatement - import state depending of the file type
 * @param {string} [placeholder] - if a placeholder is provided, the import will be added before the placeholder,
 *                                 otherwise at the end of file
 * @async
 */
async function addImport(path, importStatement, placeholder) {

  const asyncReadFile = util.promisify(fs.readFile);

  try {
    let content = await asyncReadFile(path, "utf8");
    if (content.includes(importStatement)) {
      console.log(chalk.yellow("! ") + "import " + chalk.bgWhite.black(importStatement) + " was already added!");
      return;
    }
    // add before the placeholder
    if (placeholder) {
      content = content.replace(placeholder, `${importStatement}\n${placeholder}`);
    }
    // append to the file. ignore the last empty line.
    else {
      content = content.replace(/\n\n$/g, "\n") + `${importStatement}\n`;
    }

    await writeFile(path, content);
  }
  catch (err) {
    console.log(chalk.red("!") + " Couldn't read " + chalk.gray(path) + " to add import:");
    console.error(err);
  }
}

/**
 * checks if for the given file path a file exists
 *
 * @param {*} path - path of the file to check if exist
 * @returns {Promise<Boolean>}
 */
function fileExist(path) {
  return new Promise((resolve, _reject) => {
    fs.open(path, "r", (err, _fd) => {
      if (err) {
        resolve(false);
      }
      else {
        resolve(true);
      }
    });
  });
}

/**
 * if in interactive mode, the user will be asked in the cli if the file should be overridden
 * in non interactive mode, permission as always granted.
 *
 * @param {string} filename - name of the file which needs permission to be overridden
 * @returns {Promise<Boolean>}
 */
function getPermission(filename) {
  if (!useInquirer) return Promise.resolve(true);

  return new Promise(async (resolve, reject) => {
    console.log(chalk.gray(filename) + " already " + chalk.red("exist") + ".");
    const answers = await inquirer.prompt([
      // override
      {
        type: "list",
        name: "override",
        message: "should it be overwritten?",
        choices: ["skip", "override"]
      }
    ]);

    if (answers.override === "override") {
      // permission to override file was granted
      resolve();
    }
    else {
      reject();
    }
  });
}

/**
 * generates a new file at the given path and with the given content
 *
 * @param {string} path - path for the the file
 * @param {string} content - content of the new file
 * @async
 */
async function writeFile(path, content) {
  const asyncWriteFile = util.promisify(fs.writeFile);
  await mkdirp(dirname(path));
  await asyncWriteFile(path, content);
}

/**
 * changes the first letter of the given text to uppercase
 *
 * @param {string} name - name
 * @returns {string}
 */
function firstLetterToUpperCase(name) {
  return name.charAt(0).toUpperCase() + name.substring(1);
}

/**
 * changes the first letter of the given text to lowercase
 *
 * @param {string} name - name
 * @returns {string}
 */
function firstLetterToLowerCase(name) {
  return name.charAt(0).toLowerCase() + name.substring(1);
}

/**
 * generates a file with the given content at the given path,
 * if the file already exist, the user will be asked to override or skip this file generation
 *
 * @param {string} filename - filename for the new file
 * @param {string} content - content of the new file
 * @param {string} [dir] - optional directory for the file. Default the "src/components" will be used
 * @async
 */
async function generateFile(filename, content, dir = COMPONENTS_DIR) {
  const path = pathResolve(`${dir}/${filename}`);

  if (await fileExist(path)) {
    try {
      await getPermission(path);
    }
    // no permission --> don't modify file
    catch {
      return;
    }
  }
  try {
    await writeFile(path, content);
    if (gitAdd) {
      await simpleGit.add(path);
    }
    console.log(chalk.green("âœ“ " + path) + " was generated!");
  }
  catch (err) {
    console.log(chalk.red("X " + path), " file couldn't be created :( ", err);
  }
}

/**
 * returns the template function from the user or the default templates if the user did not override it
 *
 * @param {string} filename - template filename
 * @returns {function}
 */
function getTemplate(filename) {
  let template;

  try {
    template = require(pathResolve(`${TEMPLATES_DIR}/${filename}`));
  }
  // user did not provide a template, use the default one
  catch (_error) {
    template = require(`./templates/${filename}`);
  }

  return template;
}

/**
 * generates boilerplate files for a new components according to the provided options
 *
 * @param {Object} options - options for the creation of the new components necessary files
 * @param {boolean} [isInteractive=false] - should the user be asked in the CLI when new information / permission is needed.
 *                                          Otherwise it assumes always the permission to be granted
 * @param {string} namespace - project namespace, usually a abbreviation of the project/client name. e.g. pv. see pv.config.namespace
 * @param {string} name - components name. With lowercase and one space in between words. e.g. "related topics"
 * @param {string} type - components type one of "Element", "Module", "Page"
 * @param {boolean} [hasScss=false] - component needs a .scss file
 * @param {boolean} [hasHbs=false] - component needs a .hbs file
 * @param {string} [dataFile] - should use a dedicated file for the assembles model for the component. options: ".json", ".yaml".
 *                               {see ../bin/enquiry.DATA_FILE_TYPES}
 * @param {boolean} [hasTs=false] - component needs a .ts file
 * @param {boolean} [hasJs=false] - component needs a .js file
 * @param {boolean} [hasUnit=false] - and unit test file (.spec.js)
 * @param {boolean} [hasGalen=false] - and galen test files
 * @param {boolean} [gitAdd=false] - git stage the new files

 * @async
 */
module.exports = async function generateFiles({
  isInteractive,
  namespace,
  name,
  type,
  hasScss = false,
  hasHbs = false,
  dataFile,
  hasTs = false,
  hasJs = false,
  hasUnit = false,
  hasGalen = false,
  gitAdd: gitAddOption = false,
}) {

  useInquirer = Boolean(isInteractive);

  gitAdd = Boolean(gitAddOption);

  // e.g. "related content" -> "Related Topics"
  const uppercase = name
    .split(" ")
    .map(firstLetterToUpperCase)
    .join(" ");
  // e.g. "RelatedTopics"
  const pascalCase = uppercase.replace(/ /g, "");
  // e.g. "relatedTopics"
  const camelCase = firstLetterToLowerCase(pascalCase);
  // e.g. "related-topics"
  const kebabCase = name.split(" ").join("-");
  // e.g. "PVRelatedTopics"
  const constructorName = namespace.toUpperCase() + pascalCase;

  // e.g. "related topics" -> "pv-m-related-topics"
  const baseName =
    [
      namespace,
      // use -m- for "Organism"s as well.
      type === "Element" ? "e" : "m",
      kebabCase
    ].join("-");


  /**
   * Object passed to all templates. provides information that the user entered in the cli,
   * and names which will be used in the templates
   * @typedef {Object} TemplateOptions
   * @property {string} name - e.g. "related content"
   * @property {string} uppercase - e.g. "Related Topics"
   * @property {string} pascalCase - e.g. "RelatedTopics"
   * @property {string} camelCase - e.g. "relatedTopics"
   * @property {string} kebabCase - e.g. "related-topics"
   * @property {string} constructorName - e.g. "PVRelatedTopics"
   * @property {string} componentName - e.g. "pv-m-related-topics"
   * @property {boolean} isCustomElement - component has a js file and therefor is a custom element
   * @property {string} type - component type: "Element" | "Module" | "Page"
   * @property {boolean} hasScss - component has .scss file
   * @property {boolean} hasHbs - component has .hbs file
   * @property {DATA_FILE_TYPES} [dataFile] - handlebars data is in a yaml or json file
   * @property {boolean} hasTs - has a .ts file
   * @property {boolean} hasJs - has a .js file
   * @property {boolean} hasUnit - has unit test file
   * @property {boolean} hasGalen - has galen test files
   * @property {boolean} gitAdd - will be staged with git
   */
  const templateOptions = {
    name,
    type,
    hasScss,
    hasHbs,
    dataFile,
    hasTs,
    hasJs,
    hasUnit,
    hasGalen,
    gitAdd,
    uppercase,
    pascalCase,
    camelCase,
    kebabCase,
    constructorName,
    componentName: baseName,
    isCustomElement: Boolean(hasJs || hasTs),
  };

  // hbs page
  if (type === "Page") {
    // generate new hbs page
    await generateFile(`${kebabCase}.hbs`, hbsPageTpl(templateOptions), PAGES_DIR);
    // html import
    await addImport(
      PAGES_MAIN,
      `<a href="pages/${kebabCase}.html"> ${name} </a>`,
      `<!-- ${IMPORT_PLACEHOLDER} -->`);

    // no additional files
    return;
  }

  // md file & demo
  if (hasScss || hasHbs) {
    await generateFile(`${baseName}/${baseName}.md`, mdTpl(templateOptions));
    await generateFile(`${baseName}/demo/${baseName}--demo.hbs`, hbdDemoTpl(templateOptions));
  }

  // scss
  if (hasScss) {
    // scss file
    await generateFile(`${baseName}/${baseName}.scss`, scssTpl(templateOptions));
    // scss import
    await addImport(SCSS_MAIN, `@import "../components/${baseName}/${baseName}";`);
  }

  // hbs file
  if (hasHbs) {
    await generateFile(`${baseName}/${baseName}.hbs`, hbsTpl(templateOptions));
  }

  // .json data file
  if (dataFile === DATA_FILE_TYPES.JSON) {
    // add `__data` suffix for better distinguishing between partial and data
    // e.g. `{{> pv-m-related-topics pv-m-related-topics__data}}`
    await generateFile(`${baseName}/${baseName}__data.json`, jsonTpl(templateOptions));
  }

  // .yaml data file
  if (dataFile === DATA_FILE_TYPES.YAML) {
    await generateFile(`${baseName}/${baseName}__data.yaml`, yamlTpl(templateOptions));
  }

  // unit test
  if (hasUnit) {
    await generateFile(`${baseName}/specs/unit/${baseName}.spec.js`, unitTpl(templateOptions));
    // add import
    await addImport(KARMA_MAIN, `import "Components/${baseName}/specs/unit/${baseName}.spec.js";`);
  }

  // galen tests
  if (hasGalen) {
    await generateFile(`${baseName}/specs/galen/${baseName}.test.js`, galenTestTpl(templateOptions));
    await generateFile(`${baseName}/specs/galen/${baseName}.gspec`, galenSpecTpl(templateOptions));
  }

  // js
  if (hasJs) {
    await generateFile(`${baseName}/${baseName}.js`, jsTpl(templateOptions));

    // add component import
    await addImport(JS_COMPONENTS_MAIN, `import "Components/${baseName}/${baseName}";`);
  }

  // ts
  if (hasTs) {
    await generateFile(`${baseName}/${baseName}.ts`, tsTpl(templateOptions));

    // add component import
    await addImport(TS_COMPONENTS_MAIN, `import "Components/${baseName}/${baseName}";`);
  }
};
